#sorting inside the list of values

val products = sc.textFile("/user/cloudera/sqoop_import/products")
val productsMap = products.map(rec => (rec.split(",")(1),rec))
val productsGroupBy = productsMap.groupByKey()
productsGroupBy.collect().foreach(println)

val productsGroupSorted = productsGroupBy.map(x => (x._1, x._2.toList.sortBy(x => x.split(",")(4).toFloat))).collect().foreach(println)
# we can use flatmap to get the flattened results, note that here we are using only the iterable/list as flatmap takes in list/array
val productsGroupSorted = productsGroupBy.flatMap(x => ( x._2.toList.sortBy(x => x.split(",")(4).toFloat))).collect().foreach(println)

# define  normal functions to sort and use it
def sort_flat(rec: (String, Iterable[String])):(Iterable[String]) = {
return rec._2.toList.sortBy(x => x.split(",")(4).toFloat)
}

val productsGroupSorted = productsGroupBy.flatMap(sort_flat(_)).collect().foreach(println)

#Function to get topN records by Price

def topN(rec : (String, Iterable[String]), topN:Int) : (Iterable[String]) = {
return rec._2.toList.sortBy(-_.split(",")(4).toFloat).take(topN)
}

val productsGroupSorted = productsGroupBy.flatMap(topN(_,2)).collect().foreach(println)

# Function to get topN priced products by category
def getTopDenseN(rec: (String, Iterable[String]), topN: Int) : (Iterable[String]) = {
	var prodPrices : List[Float] = List()
 	var topNPrices : List[Float] = List()
	var sortedRecs : List[String] = List()
	
	for(i <- rec._2){ 
		prodPrices = prodPrices:+ i.split(",")(4).toFloat
		}
	topNPrices = prodPrices.distinct.sortBy(k => -k).take(topN)
	sortedRecs = rec._2.toList.sortBy(-_.split(",")(4).toFloat)
	var x:List[String] = List()

	for(i <- sortedRecs){
    		if(topNPrices.contains(i.split(",")(4).toFloat))
		x = x:+ i
		}
	return x
      }
	
val productsGroupSorted = productsGroupBy.flatMap(getTopDenseN(_,2)).collect().foreach(println)

-------------------------------------------------------------------------------------------------------------------------------------------------
# using sql to do ranking

select * from products order by product_price desc;

select * from products order by product_category_id, product_price desc limit by 10;

# in the above case it may cause a bottle neck , as it is a single threaded model and product_category_id is sorted in ascending order and product_price is sorted in descending order, product_category_id sorting is not required in this case, hive provides a way to do this as shown in below query

select * from products distribute by product_category_id sort by product_category_id, product_price desc

#hive provides a denseRank function to obtain topNranked records, this query may not run on spark even with hive context
select * from ( select p.*, dense_rank() over (partition by product_category_id order by product_price_desc) dr 
               from products p
               distribute by product_category_id) q
               where dr <=2 order by product_category_id, dr; 


